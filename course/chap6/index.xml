<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chapter 6 | ロボットシステム入門</title><link>https://matsuolab.github.io/roomba_hack_course/course/chap6/</link><atom:link href="https://matsuolab.github.io/roomba_hack_course/course/chap6/index.xml" rel="self" type="application/rss+xml"/><description>Chapter 6</description><generator>Wowchemy (https://wowchemy.com)</generator><language>ja</language><copyright>© 2023 Tokyo Robot And Intelligence Lab (TRAIL)</copyright><lastBuildDate>Sun, 09 Sep 2018 00:00:00 +0000</lastBuildDate><image><url>https://matsuolab.github.io/roomba_hack_course/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_2.png</url><title>Chapter 6</title><link>https://matsuolab.github.io/roomba_hack_course/course/chap6/</link></image><item><title>serviceとactionlib</title><link>https://matsuolab.github.io/roomba_hack_course/course/chap6/service-actionlib/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack_course/course/chap6/service-actionlib/</guid><description>&lt;h2 id="learn">Learn&lt;/h2>
&lt;p>これまでは，トピックを使った通信によりロボットシステムを構築してきました．
トピック通信には，&lt;/p>
&lt;ul>
&lt;li>通信の相手を仮定しない &amp;hellip; subscriberがいなくてもpublishできる&lt;/li>
&lt;li>非同期通信・処理ができる &amp;hellip; publisherはメッセージをpublishしたらすぐに次の処理を始める（=subscriberの処理が終わるのを待たない）&lt;/li>
&lt;/ul>
&lt;p>などの特徴があり、シンプルにノード間の通信を実現できました．&lt;br>
しかし，逆に言えば，&lt;/p>
&lt;ul>
&lt;li>通信の相手を仮定する &amp;hellip; 呼び出し側のノードが，処理を実行するノードの処理結果によって振るまいを変える&lt;/li>
&lt;li>同期通信・処理 &amp;hellip; 呼び出し側のノードが，処理を実行するノードで処理が完了するまで待つ&lt;/li>
&lt;/ul>
&lt;p>のような処理（クライアント・サーバ型の通信と呼ばれることが多い）を
トピックによって実現することは大変です．&lt;/p>
&lt;p>このような比較的複雑な通信を実現するための通信方式として，
ROSはサービス（service）とアクション（actionlib）を用意しています．&lt;/p>
&lt;h3 id="service">service&lt;/h3>
&lt;h4 id="serviceとは">serviceとは&lt;/h4>
&lt;p>service通信は，クライアント・サーバ型の通信を実現する最も基本的な方法です。&lt;/p>
&lt;p>サービスを提供するノード(service server)と，サービスを呼び出すノード(service client)の間の通信を可能にします．&lt;br>
以下のような流れで使用します．&lt;/p>
&lt;ol>
&lt;li>clientがserverに引数を渡す(処理をリクエストする)&lt;/li>
&lt;li>引数を受け取ったserverが何らかの処理を実行する&lt;/li>
&lt;li>serverが処理結果を返り値としてclientに返す&lt;/li>
&lt;li>clientは受け取った値に基づいて処理を続行する&lt;/li>
&lt;/ol>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../ros_service.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>pythonでは，rospyモジュールの&lt;code>rospy.Service()&lt;/code>や
&lt;code>rospy.ServiceProxy()&lt;/code>を使用することで，サーバ・クライアント
を簡単に実装することができます
（&lt;a href="http://wiki.ros.org/ja/ROS/Tutorials/WritingServiceClient%28python%29" target="_blank" rel="noopener">参考&lt;/a>）．&lt;/p>
&lt;p>以下のように，コマンドラインからサービスを利用することもできます．&lt;/p>
&lt;pre>&lt;code class="language-bash"># サーバを呼び出す
$ rosservice call &amp;lt;ServiceName&amp;gt; &amp;lt;Arguments&amp;gt;
# 存在するサービスの一覧を表示
$ rosservice list
# サービスのメッセージ型を表示
$ rosservice type &amp;lt;ServiceName&amp;gt;
&lt;/code>&lt;/pre>
&lt;h4 id="serviceのデータ型">serviceのデータ型&lt;/h4>
&lt;p>サービスにおいて使用されるデータの型は.srvファイルに記述されています．
トピックにおいて使用されるデータの型は.msgファイルに記述されていましたが，
サービスの場合は引数と返り値の二つの形式を定義する必要がある点が異なります．&lt;br>
例としてstd_srvs/SetBoolを示します．引数と返り値の間に&lt;code>---&lt;/code>を入れて定義します．&lt;/p>
&lt;pre>&lt;code>bool data
---
bool success
string message
&lt;/code>&lt;/pre>
&lt;h3 id="actionlib">actionlib&lt;/h3>
&lt;p>サービス通信では，クライアントはサーバ側の処理が終わるまで処理を停止するため，
サーバで長い時間がかかるような処理を行う（計算量が大きい，または，移動に時間がかかるなど）場合には，
クライアントの処理が長い間停止してしまうという問題があります．&lt;/p>
&lt;p>処理の呼び出し側のプログラムを停止させずに，かつ，
処理の結果や途中経過を受け取って利用できるようにしたものがアクション(actionlib)通信です．&lt;/p>
&lt;p>actionlibは5つのトピック通信を組み合わせることで実現されています．
詳しい説明は&lt;a href="https://qiita.com/srs/items/a39dcd24aaeb03216026#%E6%A6%82%E8%A6%81" target="_blank" rel="noopener">qiitaのROS講座&lt;/a>を参照してください．&lt;/p>
&lt;p>pythonでは，actionlibのサーバやクライアントも，&lt;/p>
&lt;pre>&lt;code class="language-python">import actionlib
&lt;/code>&lt;/pre>
&lt;p>したのちに，他の通信方式と同様に&lt;code>actionlib.SimpleActionServer&lt;/code>として，簡単に作成できます（&lt;a href="http://wiki.ros.org/ja/actionlib_tutorials/Tutorials/Writing%20a%20Simple%20Action%20Server%20using%20the%20Execute%20Callback%20%28Python%29" target="_blank" rel="noopener">ドキュメント&lt;/a>）．&lt;/p>
&lt;p>今回の演習では，簡単のためaction serverの作成は行いません．
変わりに，移動のためのactionとして，&lt;code>move_base&lt;/code>パッケージの中で定義されている&lt;code>move_base&lt;/code>というactionを使うことにしましょう．&lt;/p>
&lt;!-- service serverやservice clientも作成してないが...? -->
&lt;p>実はこのパッケージは&lt;/p>
&lt;pre>&lt;code class="language-bash">roslaunch navigation_tutorial navigation.launch
&lt;/code>&lt;/pre>
&lt;p>を実行して&lt;code>move_base&lt;/code>ノードを起動した際に既に利用されていました．&lt;/p>
&lt;!--（これまでは，そのパッケージの中でサブスクライバとして定義された`move_base_simple/goal`というトピックにpublishすることで移動をしていました）-->
&lt;p>&lt;code>move_base&lt;/code>パッケージの詳細は&lt;a href="http://wiki.ros.org/move_base" target="_blank" rel="noopener">ドキュメント&lt;/a>を参照してください．&lt;/p>
&lt;p>同様に，action clientも&lt;code>actionlib.SimpleActionClient&lt;/code>を利用することで簡単に作成できます．&lt;br>
例えば，&lt;code>move_base&lt;/code>のaction clientを実装する際には，&lt;/p>
&lt;pre>&lt;code class="language-python">import actionlib
import tf
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from geometry_msgs.msg import Quaternion
action_client = actionlib.SimpleActionClient('move_base', MoveBaseAction)
action_client.wait_for_server() # action serverの準備ができるまで待つ
goal = MoveBaseGoal() # goalのメッセージを作成
goal.target_pose.header.frame_id = 'map' # マップ座標系でのゴールとして設定
goal.target_pose.header.stamp = rospy.Time.now() # 現在時刻
# ゴールの姿勢を指定
goal.target_pose.pose.position.x = X
goal.target_pose.pose.position.y = Y
q = tf.transformations.quaternion_from_euler(0, 0, YAW) # 回転はquartanionで記述するので変換
goal.target_pose.pose.orientation = Quaternion(q[0], q[1], q[2], q[3])
action_client.send_goal(goal) # サーバにゴールを送信
&lt;/code>&lt;/pre>
&lt;p>のようにクライアントの&lt;code>send_goal&lt;/code>メソッドでゴールを指定できます．&lt;/p>
&lt;p>その後，&lt;/p>
&lt;pre>&lt;code class="language-python">action_client.wait_for_result(rospy.Duration(30))
&lt;/code>&lt;/pre>
&lt;p>とすると，結果が返ってくるまで（この場合30秒間）クライアントの処理をブロックすることができ，&lt;/p>
&lt;pre>&lt;code class="language-python">result = action_client.wait_for_result(rospy.Duration(30))
&lt;/code>&lt;/pre>
&lt;p>とすることで，&lt;code>result&lt;/code>変数に処理の結果を格納できます．&lt;/p>
&lt;h2 id="演習">演習&lt;/h2>
&lt;details class="spoiler " id="spoiler-1">
&lt;summary>【jetson・開発マシン】起動準備&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">cd roomba_hack
git fetch
git checkout feature/integrate
(jetson) ./RUN-DOCKER-CONTAINER.sh
(開発マシン) ./RUN-DOCKER-CONTAINER.sh 192.168.10.7x
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-2">
&lt;summary>【開発マシン】scriptベースのnavigationを実行してみる&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">(開発マシン)(docker) roslaunch navigation_tutorial navigation.launch
(開発マシン)(docker) rosrun navigation_tutorial topic_goal.py
(開発マシン)(docker) rosrun navigation_tutorial action_goal.py
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-3">
&lt;summary>【開発マシン】RealSenseで検出した障害物をコストマップに追加してみよう&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">(開発マシン)(docker) roslaunch three-dimensions_tutorial detection_pc.launch
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-4">
&lt;summary>（総合課題）障害物を避けながらnavigationする&lt;/summary>
&lt;p>&lt;p>Lidarに映らない物体も画像ベースで検出しコストマップに追加することでナビゲーション時にぶつからないようにしましょう。&lt;/p>
&lt;p>ヒント&lt;/p>
&lt;ul>
&lt;li>物体検出結果に基づいて物体部分以外をマスクしたデプス画像をpublishする&lt;/li>
&lt;li>depth2pc.launchでそれをsubscribeし、point(cloud)に変換する&lt;/li>
&lt;li>変換されたpointからmap座標系での位置を取得する&lt;/li>
&lt;li>costmapに反映する&lt;/li>
&lt;li>&lt;code>move_base&lt;/code>アクションを使ってナビゲーションを実装しよう．
&lt;ul>
&lt;li>するとactionがタイムアウトした場合や，&lt;code>KeyboardInterrupt&lt;/code>された場合に&lt;code>cancel_goal&lt;/code>メソッドを使うことでactionをキャンセルできるように拡張できるはずです．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>さらに，PyTorchを使用した自作の分類器やネット上の分類器をシステムに組み込んで（例えばセグメンテーションモデルなど），よりよく動作するように改良してみましょう．&lt;/p>
&lt;/p>
&lt;/details></description></item></channel></rss>