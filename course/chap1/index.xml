<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chapter 1 | ロボットシステム入門</title><link>https://matsuolab.github.io/roomba_hack_course/course/chap1/</link><atom:link href="https://matsuolab.github.io/roomba_hack_course/course/chap1/index.xml" rel="self" type="application/rss+xml"/><description>Chapter 1</description><generator>Wowchemy (https://wowchemy.com)</generator><language>ja</language><copyright>© 2024 Tokyo Robot And Intelligence Lab (TRAIL)</copyright><lastBuildDate>Sun, 09 Sep 2018 00:00:00 +0000</lastBuildDate><image><url>https://matsuolab.github.io/roomba_hack_course/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_2.png</url><title>Chapter 1</title><link>https://matsuolab.github.io/roomba_hack_course/course/chap1/</link></image><item><title>開発環境</title><link>https://matsuolab.github.io/roomba_hack_course/course/chap1/%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83/</link><pubDate>Tue, 06 Jun 2023 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack_course/course/chap1/%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83/</guid><description>&lt;p>ロボットシステムの開発環境に使われている要素の概要を理解する&lt;/p>
&lt;!--
## スライド
https://docs.google.com/presentation/d/1-q6zq3vV91GTj7mw9uqwT4B8LyHDpFHBNVi4lEyCa5A/edit?usp=sharing
-->
&lt;h2 id="learn">Learn&lt;/h2>
&lt;h3 id="linuxコマンド">Linuxコマンド&lt;/h3>
&lt;p>コンピュータやロボットの研究・開発では、LinuxというOS(Operating System)がよく使用されます。&lt;br>
ROSはLinux(とくにUbuntuというディストリビューション)で動作することを想定されているため、ROSを使うにはある程度Linuxの知識が必要になります。
Linuxについてあまり知らないという方は、前もって調べておくと良いでしょう(&lt;a href="https://kitsune.blog/engineer/linux" target="_blank" rel="noopener">参考&lt;/a>)。
特に、&lt;a href="https://kitsune.blog/linux-command-summary" target="_blank" rel="noopener">Linuxコマンド&lt;/a>について軽く知っておくとROS自体の理解もスムーズになります。&lt;/p>
&lt;pre>&lt;code>&amp;quot;&amp;quot;&amp;quot;
ここではLinuxのコマンドを十分に説明できないので、コマンドの例を挙げることに留めます。
詳しいサイトに沿って自分で使いながら覚えていくことをお勧めします。
&amp;quot;&amp;quot;&amp;quot;
# カレントディレクトリ(自分が今いるディレクトリ)を確認
pwd
# ディレクトリ内のファイル・ディレクトリの表示
ls
# カレントディレクトリを変更
cd &amp;lt;DirectoryName&amp;gt;
# ディレクトリ作成
mkdir &amp;lt;NewDirectoryName&amp;gt;
# ディレクトリ削除
rmdir &amp;lt;DirectoryName&amp;gt;
# ファイル作成
touch &amp;lt;NewFileName&amp;gt;
# ファイル消去
rm &amp;lt;FileName&amp;gt;
# ファイルの内容を表示
cat &amp;lt;FileName&amp;gt;
&lt;/code>&lt;/pre>
&lt;h3 id="エディタ">エディタ&lt;/h3>
&lt;p>プログラミング言語でコードを書くときに使用するツールをEditor（エディタ）と呼びます。&lt;br>
テキストファイルを編集するツールなのでメモ帳でも同じ事ができるのですが、エディタには便利な機能が多く、効率よくコードが編集できるようになります。&lt;br>
研究室のPCでは以下の二つが使用できます。&lt;/p>
&lt;ul>
&lt;li>vim
&lt;ul>
&lt;li>シンプルで使いやすいエディタ。&lt;/li>
&lt;li>macだと標準で使える。
&lt;ul>
&lt;li>ターミナルで&lt;code>vimtutor&lt;/code>を実行するとチュートリアルが受けられる.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Windowsだとインストールする必要がある。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>vscode
&lt;ul>
&lt;li>visual studio code&lt;/li>
&lt;li>ダウンロードする必要がある&lt;/li>
&lt;li>さまざまな機能を追加でき、とても便利&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=csOaPNMDEwg&amp;amp;ab_channel=%E3%81%97%E3%81%BE%E3%81%B6%E3%83%BC%E3%81%AEIT%E5%A4%A7%E5%AD%A6" target="_blank" rel="noopener">詳しい動画&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="gitgithub">Git/GitHub&lt;/h3>
&lt;ul>
&lt;li>Gitとは
&lt;ul>
&lt;li>
&lt;p>ファイルのバージョン管理が簡単にできるツール。&lt;/p>
&lt;p>使い方を知っておくと開発が快適になります。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://qiita.com/noshishi/items/2821c01d590bf9c96038" target="_blank" rel="noopener">詳しい記事(コマンドなし)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://qiita.com/satona-oinuma/items/97205ca0ce04dcae2adb" target="_blank" rel="noopener">詳しい記事(コマンドあり)&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>GitHubとは
&lt;ul>
&lt;li>
&lt;p>gitで管理しているファイルを他の人と共有できるようにするサービス。&lt;/p>
&lt;p>チーム開発で大変重宝します。&lt;br>
自分が書いたコードを公開して世界中の人に使ってもらったり、他の人が公開しているコードを使わせてもらうこともできます。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.co.jp/">https://github.co.jp/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://qiita.com/b150005/items/508009234bf9813b230f" target="_blank" rel="noopener">詳しい記事&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://learn.utcode.net/docs/team-development/git-workflow/" target="_blank" rel="noopener">GitとGitHubを用いたワークフロー&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>このサイトもGitHubを使って開発しています。(&lt;a href="https://github.com/matsuolab/roomba_hack_course" target="_blank" rel="noopener">このサイトのリポジトリ&lt;/a>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>公開されているリポジトリの例&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/gundam-global-challenge/gundam_robot">https://github.com/gundam-global-challenge/gundam_robot&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="docker">Docker&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Dockerとは&lt;/p>
&lt;p>「データやプログラムを隔離できる」仕組み。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>例えば、コンピュータの中でシステムAとシステムBを動かしたいとします。そして、これらは他のシステムCに依存しているものとします。&lt;br>
もし、AがCのver.2にのみ対応していて、BはCのver.3にのみ対応していた場合、Bを実行できるようにCをver.3にしてしまうと、Aが実行できなくなってしまいます。&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../docker_1.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>このような場合、dockerコンテナを複数作成し（コンテナI、コンテナIIとします）、&lt;/p>
&lt;ul>
&lt;li>コンテナIの中にはプログラムAとCのバージョン2をインストールして使い、&lt;/li>
&lt;li>コンテナIIの中にはプログラムBとCのバージョン3をインストールして使用する&lt;/li>
&lt;/ul>
&lt;p>のようなことことができます。&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../docker_2.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/li>
&lt;li>
&lt;p>コンテナの中の環境はPC本体の環境からは隔離されるため、安全に開発をすることができます(他の人が書いたプログラムが動かなくなるということも防げる)。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://kitsune.blog/docker-summary" target="_blank" rel="noopener">詳しい記事&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!-- - DockerFileのビルド
```
docker build -t &lt;image_name>:&lt;tag_name> -f &lt;Dockerfile> &lt;relative_dir>
```
- Docker Image
```
# Docker image一覧
docker images
# Docker Imageのダウンロード
docker pull &lt;image_name>:&lt;tag_name>
# 削除
docker rmi &lt;image_id>
# 不要なDocker imageを消す
docker image prune
```
- Docker Container
```
# Docker containerの起動
docker run &lt;image_name> &lt;command>
# Docker container一覧
docker ps -a
# Docker containerに接続
docker exec -it &lt;container_name> bash
```
-->
&lt;!-- ※`docker run`でよく使うオプション
- `-it`
- 標準入出力有効になる
- `--name &lt;container_name>`
- コンテナの名前の指定
- `--rm`
- コンテナを抜けた際に自動的にコンテナを削除する
- `--gpus all`
- コンテナに全gpuを渡す
- gpuの個数を指定する場合は all の代わりに数字(0, 1,...)
- gpuを指定する場合は `--gpus '"device=0,1"'`
- `-v &lt;host/path/to/dir:container/path/to/dir>`
- コンテナ内にホストのディレクトリをマウントする
- `-p &lt;host_port>:&lt;container_port>`
- ホストのポートをコンテナのポートにマップする
- コンテナ内でwebサーバを動かす場合などに使う
- `--net=host`
- コンテナとホストでネットワークを共有する(IPアドレスなどが同じになる)
- ROSノードをコンテナ内で動かす場合などはこれを使うと楽
- `--privileged`
- コンテナからのデバイスへのアクセスを許可
- コンテナからWEBカメラにアクセスしたいときなど
-->
&lt;h3 id="ssh">ssh&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://e-words.jp/w/SSH.html" target="_blank" rel="noopener">sshとは&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sshを使用することで、開発PCからルンバに載っているjetsonというコンピュータを遠隔で操作することや、各自のPCから開発PCを遠隔で操作することができる。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!--
コマンドだけあってもわからないと思うので
```
ssh &lt;username>@&lt;hostname> -p &lt;port> -i &lt;identity_file>
```
-->
&lt;h2 id="演習">演習&lt;/h2>
&lt;p>演習には個人PC, 開発PC, ルンバに搭載されているjetsonの3種類のコンピュータを用います。&lt;/p>
&lt;p>開発PC : robot_dev系, hsr_dev系&lt;/p>
&lt;p>jetson : roomba_dev系&lt;/p>
&lt;!--
&lt;details class="spoiler " id="spoiler-2">
&lt;summary>【ssh】開発用PCにsshする&lt;/summary>
&lt;p>&lt;p>個人PCから開発PCにsshする&lt;/p>
&lt;pre>&lt;code class="language-shell">(個人PC):~$ vim ~/.ssh/config
(個人PC):~$ ssh robot_dev2
&lt;/code>&lt;/pre>
&lt;p>sshに成功すると&lt;/p>
&lt;pre>&lt;code>robot_dev2@robot-dev2:~$
&lt;/code>&lt;/pre>
&lt;p>などと表記が変わり、開発PCに接続できたことが確認できます。&lt;/p>
&lt;/p>
&lt;/details>
-->
&lt;details class="spoiler " id="spoiler-3">
&lt;summary>【Linuxコマンド】グループのディレクトリを作成し移動する&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-sh">(開発PC):~$ mkdir 23_group_x
(開発PC):~$ cd 23_group_x
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-4">
&lt;summary>【git】roomba_hackリポジトリをcloneし移動する&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-sh">(開発PC):~/23_group_x$ git clone https://github.com/matsuolab/roomba_hack.git
(開発PC):~/23_group_x$ ls
# 23_group_xディレクトリの中に新しいディレクトリができていることを確認
(開発PC):~/23_group_x$ cd roomba_hack
(開発PC):~/23_group_x/roomba_hack$ ls
&lt;/code>&lt;/pre>
&lt;p>&lt;a href="https://github.com/matsuolab/roomba_hack">https://github.com/matsuolab/roomba_hack&lt;/a> をそのままダウンロードできたことが確認できると思います。&lt;/p>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-5">
&lt;summary>【git】ブランチを確認する&lt;/summary>
&lt;p>&lt;p>git branchコマンドを使ってみましょう。&lt;/p>
&lt;pre>&lt;code class="language-sh"># ローカルブランチの一覧を表示
(開発PC):~/23_group_x/roomba_hack$ git branch
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-6">
&lt;summary>【docker】roomba_hackの開発環境のdockerイメージをビルドする&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-sh"># shellファイルの中身をcatコマンドで確認してみます。
(開発PC):~/23_group_x/roomba_hack$ cat BUILD-DOCKER-IMAGE.sh
# ファイルの中身が表示される
# ファイルの最後の
# docker build . -f docker/${DOCKERFILE_NAME} -t ${IMAGE_NAME}:${TAG_NAME} --build-arg BASE_IMAGE=${BASE_IMAGE}
# の部分でDockerイメージのビルドを実行するようです。
# shellファイルを実行してdockerイメージのビルドを行います。
(開発PC):~/23_group_x/roomba_hack$ ./BUILD-DOCKER-IMAGE.sh
&lt;/code>&lt;/pre>
&lt;p>「イメージ」とは、dockerコンテナを作成するための素となるもので、コンテナの設計図のようなものです。上のコマンドを実行することで、roomba_hackの開発環境のdockerイメージが作成されます（まだコンテナ自体は作っていません）。&lt;/p>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-7">
&lt;summary>【ssh】jetsonにsshする&lt;/summary>
&lt;p>&lt;p>開発用PCからルンバに載っているjetson nanoへsshします。&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC):~/23_group_x/roomba_hack$ ssh roomba_dev2
roomba_dev2@roomba-dev-jetson2:~$
&lt;/code>&lt;/pre>
&lt;p>先頭の表記が&lt;code>roomba_dev2@roomba-dev-jetson2&lt;/code>と変わり、jetsonへ接続されたことがわかります。&lt;/p>
&lt;p>jetsonでも同様にグループのディレクトリを作成し、移動し、roomba_hackリポジトリをcloneしてみましょう。&lt;/p>
&lt;/p>
&lt;/details>
&lt;!--
&lt;details class="spoiler " id="spoiler-8">
&lt;summary>【ssh】VNCを使う&lt;/summary>
&lt;p>&lt;p>個人PCから開発PCにsshで接続&lt;/p>
&lt;pre>&lt;code class="language-shell">(個人PC):~$ ssh robot_dev2 -L 5900:localhost:5900
&lt;/code>&lt;/pre>
&lt;p>手元のVNC viewerでlocalhost:5900を開く&lt;/p>
&lt;/p>
&lt;/details>
-->
&lt;!--
TODO:
- RUN-DOCKER-CONTAINER.shの中身を説明する
- BUILD-DOCKER-IMAGE.shの中身を説明する
- sshに必要な設定を説明する
- VNCに必要な設定を説明する
- VNC viewerの使い方を説明する
--></description></item><item><title>ROSとは</title><link>https://matsuolab.github.io/roomba_hack_course/course/chap1/ros/</link><pubDate>Tue, 06 Jun 2023 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack_course/course/chap1/ros/</guid><description>&lt;p>ロボット開発によく用いられるROSの概要を理解する&lt;/p>
&lt;h2 id="learn">Learn&lt;/h2>
&lt;h3 id="rosの概要">ROSの概要&lt;/h3>
&lt;p>ROS(Robot Operating System)は、ロボット・アプリケーション開発に便利な機能を提供するフレームワークです。
フレームワークとは、プログラミング言語を特定の目的に特化させて使うためのツールのことです。
具体的には以下にあげる機能を提供しています。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>メッセージ通信&lt;/p>
&lt;ul>
&lt;li>プロセス間、コンピュータ間の通信ライブラリが提供されています。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>デバイスドライバ&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ROSに対応しているセンサやアクチュエータを搭載したロボットであれば、違うロボットであってもほぼ同じソースコードを使用して動かすことができます。&lt;br>
roombaを動かすために書いたソースコードをそのまま使用してHSRを動かす、といったことができます。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/ros-drivers">https://github.com/ros-drivers&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://wiki.ros.org/Sensors">http://wiki.ros.org/Sensors&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ライブラリ&lt;/p>
&lt;ul>
&lt;li>ロボットを動作させるソフトウェア(ナビゲーション、マニピュレーション)の基本機能の大半が提供されています。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>視覚化ツール&lt;/p>
&lt;ul>
&lt;li>ロボットの内部状態やセンサ出力を2次元、3次元で視覚化するRvizや3次元動力学シミュレータのGazeboなどが提供されています。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>パッケージ管理&lt;/p>
&lt;ul>
&lt;li>多種多様なプログラミング言語(python, C++, &amp;hellip;)、依存関係で記述されたプログラム同士を統合的に使用することが可能です。&lt;/li>
&lt;li>これにより、経路計画など処理が重いプロセスはC++でコードを書き、画像認識など機械学習系のプロセスはpythonでコードを書く、といったこともできるようになります。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="rosのメッセージ通信">ROSのメッセージ通信&lt;/h3>
&lt;p>ロボットを動かす際には、多くのプログラムを並列して実行し、それぞれがデータをやりとりする必要があります。
ROSはそのようなプログラム間の通信に必要な機能を提供しています。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ノード(node)&lt;/p>
&lt;ul>
&lt;li>ROSでは、一つのプログラム単位を「ノード(node)」と呼びます。&lt;/li>
&lt;li>基本的には、一つのファイルが一つのノードに対応しています。&lt;/li>
&lt;li>各ノードはtopic、service、actionlibなどの通信方法を使って、他のノードとデータのやり取りを行います。ここではtopicについて説明し、serviceとactionlibについてはchaper6で説明します。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>トピック(topic)&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ROSでの、最も基本的なデータ通信の経路を「トピック(topic)」と呼びます。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ノードはメッセージをトピックへ向けて配信(Publish)し、また購読する(Subscribe)ことで他のノードと情報を共有することができます。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配信を行うノードをPublisher、購読を行うノードをSubscriberと呼びます。ノードはこのどちらかに二分することができるというわけではなく、一つのノードがpublisherであり、subscriberでもあるという状況がほとんどです。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>トピックには名前が付けられており、同じトピックに複数のノードがデータを送ったり、複数のノードが同じデータを受け取ることができます。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>メッセージ(message)&lt;/p>
&lt;p>トピックへ配信したり、購読したりするときのROSのデータ型のことを「メッセージ(message)」と呼びます。
メッセージの型はmsgファイルに記述されており、使用するプログラミング言語に依存しないデータ形式になっています。&lt;/p>
&lt;p>以下に、物体やロボットの位置を表す時によく用いる&lt;code>geomemtry_msgs/PoseStamped&lt;/code>型のmsgファイルを示します。
位置情報の時間や座標フレームの情報が含まれるheaderと座標位置を表すposeで定義されています。&lt;/p>
&lt;pre>&lt;code>std_msgs/Header header
uint32 seq
time stamp
string frame_id
geometry_msgs/Pose pose
geometry_msgs/Point position
float64 x
float64 y
float64 z
geometry_msgs/Quaternion orientation
float64 x
float64 y
float64 z
float64 w
&lt;/code>&lt;/pre>
&lt;p>各行の左側にはデータ型が、右側には変数名が記述されています。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Topic通信のイメージ
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../node.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ROSマスタ(ROS master)&lt;/p>
&lt;ul>
&lt;li>
&lt;p>「ROSマスタ(ROS master)」は、ノード、トピックの名前登録を行い、それぞれのノードが他のノードから見えるようにする役割を担っています。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通信するノード名とトピック名およびサービス名の対応が決定した後、ノード同士が「peer-to-peer」で通信します。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ROSマスタを起動するには「roscore」というコマンドを実行します（が、ロボットによっては起動時にこのコマンドが自動で実行されることが多いため、あまり意識する機会はないかもしれません）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!--
パラメータサーバは必須ではないと思うのでコメントアウト。
- パラメータサーバ(parameter server)
「パラメータサーバ(parameter server)」は、設定データを複数のノードで共有するための軽量なサーバです。
各ノードのパラメータを、パラメータサーバで一括して管理できます。
パラメータサーバもROSマスタ同様に「roscore」コマンドで起動します。
パラメータサーバで扱える型は、整数・小数・真偽値・辞書・リストになります。
-->
&lt;h3 id="rosと連動するソフトウェア">ROSと連動するソフトウェア&lt;/h3>
&lt;p>ROSは以下のようなソフトウェアと連動して使うためのパッケージを提供しています。簡単な説明にとどめるので、詳しい使い方は必要になった際に調べてください。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>OpenCV&lt;/p>
&lt;p>豊富な機能を持つ2D画像処理用のライブラリです。
カメラで撮影した画像を処理する際に使用します。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PCL(Point Cloud Library)&lt;/p>
&lt;ul>
&lt;li>3次元点群処理のライブラリ。&lt;/li>
&lt;li>HSRやRoombaにはRGBDカメラが搭載されています。DはDepthという意味で、画像の各ピクセルに距離情報を対応させたDepth画像を取得することができます。&lt;br>
このような三次元の点群の情報を処理する際にPCLを使うと便利です。&lt;/li>
&lt;/ul>
&lt;!--OpenCV同様PCLのデータ形式とROSのメッセージ形式を変換するパッケージが提供されています。-->
&lt;/li>
&lt;li>
&lt;p>OpenSLAM&lt;/p>
&lt;ul>
&lt;li>地図を効果的に使うことで、より安定したロボットのナビゲーションを行うことができます。&lt;/li>
&lt;li>移動ロボットの自己位置推定と地図生成を同時に行うSLAM(Simultaneous Localization and Mapping)という手法は、それだけで一つの研究分野になる程奥深い分野で、活発に研究が行われています。&lt;/li>
&lt;li>OpenSLAMは、SLAMのソースコードを公開するためのプラットフォームを提供しており、様々なSLAMの手法を実装しています。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!--
roombaには手がついていないので、MoveIt!の説明は省略。
- **Move it**
-->
&lt;p>これ以外にも多くのツールがROSと連動しています。&lt;/p>
&lt;h3 id="可視化ツール">可視化ツール&lt;/h3>
&lt;p>ロボット内部の大量のデータが正しく処理されているか知りたい場合、変数の中身の数値などを直接みるのは大変です。直感的にわかりづらいためミスも増えます。&lt;br>
可視化をすることで、開発やデバッグがより効率よく進められます。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>rqt&lt;/p>
&lt;p>rqtはROSのGUIフレームワークで、様々なツールを提供しています。&lt;br>
ノードの状態を可視化する&lt;code>rqt_graph&lt;/code>(下図1)、メッセージの値を時系列に沿ってプロットする&lt;code>rqt_plot&lt;/code>(下図2)などがあります。&lt;/p>
&lt;figure id="figure-図1-rqt_graph-wikipediahttpwikirosorgrqt_graphより引用">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../rqt_graph.png" alt="図1 rqt_graph [wikipedia](http://wiki.ros.org/rqt_graph)より引用" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
図1 rqt_graph &lt;a href="http://wiki.ros.org/rqt_graph">wikipedia&lt;/a>より引用
&lt;/figcaption>&lt;/figure>
&lt;figure id="figure-図2-rqt_plot-wikipediahttpwikirosorgrqt_plotより引用">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../rqt_plot.png" alt="図2 rqt_plot [wikipedia](http://wiki.ros.org/rqt_plot)より引用" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
図2 rqt_plot &lt;a href="http://wiki.ros.org/rqt_plot">wikipedia&lt;/a>より引用
&lt;/figcaption>&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;!-- http://wiki.ros.org/rqt -->
&lt;ul>
&lt;li>
&lt;p>RViz&lt;/p>
&lt;p>ロボットの三次元モデルや座標系、測定した三次元点群などを可視化するツールです。&lt;br>
三次元空間の情報以外に、カメラに写っている画像なども表示できます。&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/i--Sd4xH9ZE" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;!-- http://wiki.ros.org/ja/rviz -->
&lt;/li>
&lt;li>
&lt;p>gazebo&lt;/p>
&lt;p>オープンソースのロボット用三次元動力学シミュレータ。&lt;br>
説明は割愛します。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!-- ### パッケージ管理
- プログラミング言語
- rosdep
- -->
&lt;h2 id="演習">演習&lt;/h2>
&lt;details class="spoiler " id="spoiler-4">
&lt;summary>roombaドライバを起動し、動作することを確認する&lt;/summary>
&lt;p>&lt;ol>
&lt;li>
&lt;p>jetsonにアクセスする&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC):~$ ssh roomba_dev1
(jetson):~$
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>dockerコンテナを起動する&lt;/p>
&lt;!--余裕があれば`RUN-DOCKER-CONTAINER.sh`ファイルの中身を確認してみましょう。-->
&lt;pre>&lt;code class="language-sh">(jetson):~$ cd ~/23_group_x/roomba_hack
(jetson):~/23_group_x/roomba_hack$ ./RUN-DOCKER-CONTAINER.sh
# このファイルを実行することでdockerコンテナを作成し、コンテナの中に入る。
root@roomba-dev-jetson:~/roomba_hack#
# 上のように表示されればコンテナ内部に入れています。
&lt;/code>&lt;/pre>
&lt;p>今後docker内部であることは(docker)と表記します。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>roomba driverなどを起動するlaunchファイルを実行する&lt;br>
このタイミングでルンバの電源が入っているかを確認しておきましょう。&lt;/p>
&lt;pre>&lt;code class="language-sh">(jetson)(docker):~/roomba_hack# roslaunch roomba_bringup bringup.launch
&lt;/code>&lt;/pre>
&lt;p>起動に成功すればルンバからピッと短い音が鳴り、ターミナルには赤い文字が出続けるはずです。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-5">
&lt;summary>開発PCでdockerコンテナを起動する&lt;/summary>
&lt;p>&lt;ol>
&lt;li>
&lt;p>開発PCでdockerコンテナを起動する&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC):~$ cd ~/23_group_x/roomba_hack
(開発PC):~/23_group_x/roomba_hack$ ./RUN-DOCKER-CONTAINER.sh 192.168.10.7x
# xにはroomba_devの後につく数字を入れてください。
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>先ほどjetson内でdockerコンテナを起動しましたが、今回は開発PC内でコンテナを起動します。&lt;/li>
&lt;li>このとき引数にjetsonのIPアドレスを入れることで、jetson内のROSマスタ(前述)に、開発PCからアクセスできるようにしています。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>パッケージのビルド&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC)(docker):~/roomba_hack# cd catkin_ws
(開発PC)(docker):~/roomba_hack/catkin_ws# ls
# catkin_ws内に存在するディレクトリを確認する。
(開発PC)(docker):~/roomba_hack/catkin_ws# catkin_make
# いろいろな出力が生成される。
(開発PC)(docker):~/roomba_hack/catkin_ws# ls
# 再度catkin_ws内に存在するディレクトリを確認する。
&lt;/code>&lt;/pre>
&lt;p>ここで、buildとdevelというディレクトリが生成されていると、うまくいっています。&lt;/p>
&lt;ul>
&lt;li>build&lt;br>
C++のコードを用いる際に、コンパイルされたファイルが生成されるディレクトリ。pythonを使っているときにはほとんど意識しない。&lt;/li>
&lt;li>devel&lt;br>
様々なファイルを含んでいるが、特にsetupファイルが重要。&lt;br>
このファイルを実行することで、現在いるワークスペースに含まれるコードを使用するようにROSの環境が設定される。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>setupファイルを実行する&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC)(docker):~/roomba_hack/catkin_ws# source devel/setup.bash
# setupファイルを実行
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-6">
&lt;summary>コントローラーを使ってロボットを動かす&lt;/summary>
&lt;p>&lt;ul>
&lt;li>
&lt;p>コントローラーを起動&lt;br>
コントローラーが開発PCに接続されていることを確認してください。&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC)(docker):~/roomba_hack/catkin_ws# roslaunch roomba_teleop teleop.launch
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>コントローラのモード&lt;/p>
&lt;ul>
&lt;li>移動・停止&lt;/li>
&lt;li>自動・マニュアル&lt;/li>
&lt;li>ドッキング・アンドッキング&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>コントローラによる操縦&lt;/p>
&lt;ul>
&lt;li>移動ロック解除
L1を押している時のみ移動コマンドが動作します。&lt;/li>
&lt;li>左ジョイスティック
縦方向で前進速度(手前に倒すとバック)、横方向は回転速度に対応しています。&lt;/li>
&lt;li>左矢印
それぞれ、一定に低速度で前進・後退・回転します。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-7">
&lt;summary>Roombaの情報を取得する&lt;/summary>
&lt;p>&lt;ol>
&lt;li>
&lt;p>開発PCの新しいターミナルでdockerコンテナに入る&lt;/p>
&lt;p>bringup.launch及びteleop.launchを実行したターミナルは実行中のプログラムに占領されているので、開発PCで新しくターミナルを開いてコンテナの中に入ります。&lt;br>
すでに開発PCで起動されているコンテナに入る場合は、&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC):~/23_group_x/roomba_hack$ docker exec -it roomba_hack bash
# docker exec -it &amp;lt;コンテナ名&amp;gt; bash で起動中のコンテナに入ることができる。
&lt;/code>&lt;/pre>
&lt;p>または&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC):~/23_group_x/roomba_hack$ ./RUN-DOCKER-CONTAINER.sh
&lt;/code>&lt;/pre>
&lt;p>のいずれかのコマンドで入ることができます。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Roombaの情報を取得する&lt;/p>
&lt;p>さまざまなコマンドを使ってRoombaの情報を取得してみましょう。&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC)(docker):~/roomba_hack# rosnode list
# ノードの一覧を表示する
(開発PC)(docker):~/roomba_hack# rostopic list
# トピックの一覧を表示する
(開発PC)(docker):~/roomba_hack# rostopic echo /cmd_vel
# /cmd_velというトピックの中身を表示する
# teleop.launchを実行している状態でコントローラーを操作すると、/cmd_velの中身が変化することがわかる。
(開発PC)(docker):~/roomba_hack# rqt_graph
# ノードとトピックの関係を表示
(開発PC)(docker):~/roomba_hack# rviz
# rvizを起動
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-8">
&lt;summary>プロセスの終了・dockerコンテナから出る&lt;/summary>
&lt;p>&lt;ol>
&lt;li>
&lt;p>プロセスの終了&lt;br>
一部のプログラムは終了するまで処理を続けるため、明示的に終了させる必要があります。&lt;/p>
&lt;p>多くのプログラムは&lt;code>Ctrl+C&lt;/code>で終了します。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>dockerコンテナ・ターミナルから出る&lt;/p>
&lt;p>コマンドライン上で&lt;/p>
&lt;pre>&lt;code class="language-shell">exit
&lt;/code>&lt;/pre>
&lt;p>を実行することで、&lt;/p>
&lt;ul>
&lt;li>コンテナの中にいる場合はコンテナ外にでる。&lt;/li>
&lt;li>sshしている場合はsshを終了する。&lt;/li>
&lt;li>ターミナルを使用している場合はターミナルを終了する。&lt;/li>
&lt;/ul>
&lt;p>ことができます。また、&lt;code>Ctrl+D&lt;/code>でも同様のことができます。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/p>
&lt;/details></description></item></channel></rss>