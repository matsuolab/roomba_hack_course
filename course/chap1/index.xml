<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Chapter 1 | ロボットシステム入門</title><link>https://matsuolab.github.io/roomba_hack_course/course/chap1/</link><atom:link href="https://matsuolab.github.io/roomba_hack_course/course/chap1/index.xml" rel="self" type="application/rss+xml"/><description>Chapter 1</description><generator>Wowchemy (https://wowchemy.com)</generator><language>ja</language><copyright>© 2023 Tokyo Robot And Intelligence Lab (TRAIL)</copyright><lastBuildDate>Sun, 09 Sep 2018 00:00:00 +0000</lastBuildDate><image><url>https://matsuolab.github.io/roomba_hack_course/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_2.png</url><title>Chapter 1</title><link>https://matsuolab.github.io/roomba_hack_course/course/chap1/</link></image><item><title>開発環境</title><link>https://matsuolab.github.io/roomba_hack_course/course/chap1/%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83/</link><pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack_course/course/chap1/%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83/</guid><description>&lt;p>ロボットシステムの開発環境に使われている要素の概要を理解する&lt;/p>
&lt;h2 id="スライド">スライド&lt;/h2>
&lt;p>&lt;a href="https://docs.google.com/presentation/d/1-q6zq3vV91GTj7mw9uqwT4B8LyHDpFHBNVi4lEyCa5A/edit?usp=sharing">https://docs.google.com/presentation/d/1-q6zq3vV91GTj7mw9uqwT4B8LyHDpFHBNVi4lEyCa5A/edit?usp=sharing&lt;/a>&lt;/p>
&lt;h2 id="learn">Learn&lt;/h2>
&lt;h3 id="linuxコマンド">Linuxコマンド&lt;/h3>
&lt;p>コンピュータやロボットの研究・開発では、LinuxというOS(Operating System)がよく使用されます。&lt;br>
ROSはLinux(とくにUbuntuというディストリビューション)で動かすことを想定されているので、ROSを使うにはある程度Linuxの知識が必要になります。
Linuxについてあまり知らないという方は、以下のページに目を通しておくと良いと思います。&lt;br>
&lt;a href="https://kitsune.blog/engineer/linux" target="_blank" rel="noopener">Linuxについてまとまっているページ&lt;/a>&lt;br>
特に、&lt;a href="https://kitsune.blog/linux-command-summary" target="_blank" rel="noopener">Linuxコマンドについて&lt;/a>軽く知っておくと講義が理解しやすくなると思います。&lt;/p>
&lt;pre>&lt;code>&amp;quot;&amp;quot;&amp;quot;
ここではLinuxのコマンドを十分に説明できないので、コマンドの例を挙げることに留めます。
詳しいサイトに沿って自分で使いながら覚えていくことをお勧めします。
&amp;quot;&amp;quot;&amp;quot;
# カレントディレクトリ(自分が今いるディレクトリ)を確認
pwd
# ディレクトリ内のファイル・ディレクトリの表示
ls
# カレントディレクトリを変更
cd &amp;lt;DirectoryName&amp;gt;
# ディレクトリ作成
mkdir &amp;lt;NewDirectoryName&amp;gt;
# ディレクトリ削除
rmdir &amp;lt;DirectoryName&amp;gt;
# ファイル作成
touch &amp;lt;NewFileName&amp;gt;
# ファイル消去
rm &amp;lt;FileName&amp;gt;
# ファイルの内容を表示
cat &amp;lt;FileName&amp;gt;
&lt;/code>&lt;/pre>
&lt;h3 id="エディタ">エディタ&lt;/h3>
&lt;p>プログラミング言語でコードを書くときに使用するツールをEditor（エディタ）と呼びます。&lt;br>
テキストファイルを編集するツールなのでメモ帳でも同じ事ができるのですが、コード編集用のエディタは便利な機能が多く、効率よく書けるようになります。&lt;br>
研究室のPCでは以下の二つが使えます。&lt;/p>
&lt;ul>
&lt;li>vim
&lt;ul>
&lt;li>シンプルで使いやすいエディタ。&lt;/li>
&lt;li>macだと標準で使える。
&lt;ul>
&lt;li>ターミナルで&lt;code>vimtutor&lt;/code>を実行するとチュートリアルが受けられる.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Windowsだとインストールする必要がある。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>vscode
&lt;ul>
&lt;li>visual studio code&lt;/li>
&lt;li>ダウンロードする必要がある&lt;/li>
&lt;li>さまざまな機能を追加でき、とても便利&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=csOaPNMDEwg&amp;amp;ab_channel=%E3%81%97%E3%81%BE%E3%81%B6%E3%83%BC%E3%81%AEIT%E5%A4%A7%E5%AD%A6" target="_blank" rel="noopener">詳しい動画&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="gitgithub">Git/GitHub&lt;/h3>
&lt;ul>
&lt;li>Gitとは
&lt;ul>
&lt;li>
&lt;p>ファイルのバージョン管理が簡単にできるツール。&lt;/p>
&lt;p>使い方を知っておくと開発が快適になります。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://qiita.com/noshishi/items/2821c01d590bf9c96038" target="_blank" rel="noopener">詳しい記事(コマンドなし)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://qiita.com/satona-oinuma/items/97205ca0ce04dcae2adb" target="_blank" rel="noopener">詳しい記事(コマンドあり)&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>GitHubとは
&lt;ul>
&lt;li>
&lt;p>gitで管理しているファイルを他の人と共有できるようにするサービス。&lt;/p>
&lt;p>チーム開発で大変重宝します。&lt;br>
自分が書いたコードを公開して世界中の人に使ってもらったり、他の人が公開しているコードを使わせてもらうこともできます。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.co.jp/">https://github.co.jp/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://qiita.com/b150005/items/508009234bf9813b230f" target="_blank" rel="noopener">詳しい記事&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://learn.utcode.net/docs/team-development/git-workflow/" target="_blank" rel="noopener">GitとGitHubを用いたワークフロー&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>このサイトもGitHubを使って開発しています。もしわかりにくいところや改善要望があれば、&lt;a href="https://github.com/matsuolab/roomba_hack_course" target="_blank" rel="noopener">このサイトのリポジトリ&lt;/a>にissueを立ててくれれば、対応してくれるかもしれません。
　&lt;/p>
&lt;ul>
&lt;li>自分で編集して改善の提案を出すこともできるので、ぜひやってみてください！&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="docker">Docker&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Dockerとは&lt;/p>
&lt;p>「データやプログラムを隔離できる」仕組み。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>例えば、PCの中でAというシステムとBというシステムを動かしたいとします。そして、これらは他のCというシステムに依存しているものとします。
もし、AがCのバージョン2で動かすことにのみ対応していて、BはCのバージョン3にのみ対応していた場合、Bを動かせるようにCのバージョンを3にしてしまうと、Aが実行できなくなってしまいます。&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../docker_1.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>このような場合、dockerコンテナを複数作成し（コンテナI、コンテナIIとします）、&lt;/p>
&lt;ul>
&lt;li>コンテナIの中にはプログラムAとCのバージョン2をインストールして使い、&lt;/li>
&lt;li>コンテナIIの中にはプログラムBとCのバージョン3をインストールして使用する&lt;/li>
&lt;/ul>
&lt;p>のようなことことができます。&lt;/p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../docker_2.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;p>コンテナの中の環境はPC本体の環境からは隔離されるため、安全に開発をすることができます(他の人が書いたプログラムが動かなくなるということも防げる)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://kitsune.blog/docker-summary" target="_blank" rel="noopener">詳しい記事&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!-- - DockerFileのビルド
```
docker build -t &lt;image_name>:&lt;tag_name> -f &lt;Dockerfile> &lt;relative_dir>
```
- Docker Image
```
# Docker image一覧
docker images
# Docker Imageのダウンロード
docker pull &lt;image_name>:&lt;tag_name>
# 削除
docker rmi &lt;image_id>
# 不要なDocker imageを消す
docker image prune
```
- Docker Container
```
# Docker containerの起動
docker run &lt;image_name> &lt;command>
# Docker container一覧
docker ps -a
# Docker containerに接続
docker exec -it &lt;container_name> bash
```
-->
&lt;!-- ※`docker run`でよく使うオプション
- `-it`
- 標準入出力有効になる
- `--name &lt;container_name>`
- コンテナの名前の指定
- `--rm`
- コンテナを抜けた際に自動的にコンテナを削除する
- `--gpus all`
- コンテナに全gpuを渡す
- gpuの個数を指定する場合は all の代わりに数字(0, 1,...)
- gpuを指定する場合は `--gpus '"device=0,1"'`
- `-v &lt;host/path/to/dir:container/path/to/dir>`
- コンテナ内にホストのディレクトリをマウントする
- `-p &lt;host_port>:&lt;container_port>`
- ホストのポートをコンテナのポートにマップする
- コンテナ内でwebサーバを動かす場合などに使う
- `--net=host`
- コンテナとホストでネットワークを共有する(IPアドレスなどが同じになる)
- ROSノードをコンテナ内で動かす場合などはこれを使うと楽
- `--privileged`
- コンテナからのデバイスへのアクセスを許可
- コンテナからWEBカメラにアクセスしたいときなど
-->
&lt;h3 id="ssh">ssh&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://e-words.jp/w/SSH.html" target="_blank" rel="noopener">sshとは&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sshを使用することで、開発PCからルンバに載っているjetsonというコンピュータを遠隔で操作することや、各自のPCから開発PCを遠隔で操作することができる。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!--
コマンドだけあってもわからないと思うので
```
ssh &lt;username>@&lt;hostname> -p &lt;port> -i &lt;identity_file>
```
-->
&lt;h2 id="演習">演習&lt;/h2>
&lt;p>演習には個人PC, 開発PC, ルンバに搭載されているjetsonの3種類のコンピュータを用います。&lt;/p>
&lt;p>開発PC : robot_dev系, hsr_dev系&lt;/p>
&lt;p>jetson : roomba_dev系&lt;/p>
&lt;!--
&lt;details class="spoiler " id="spoiler-2">
&lt;summary>【ssh】開発用PCにsshする&lt;/summary>
&lt;p>&lt;p>個人PCから開発PCにsshする&lt;/p>
&lt;pre>&lt;code class="language-shell">(個人PC):~$ vim ~/.ssh/config
(個人PC):~$ ssh robot_dev2
&lt;/code>&lt;/pre>
&lt;p>sshに成功すると&lt;/p>
&lt;pre>&lt;code>robot_dev2@robot-dev2:~$
&lt;/code>&lt;/pre>
&lt;p>などと表記が変わり、開発PCに接続できたことが確認できます。&lt;/p>
&lt;/p>
&lt;/details>
-->
&lt;details class="spoiler " id="spoiler-3">
&lt;summary>【Linuxコマンド】グループのディレクトリを作成し移動する&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">(開発PC):~$ mkdir group_a
(開発PC):~$ cd group_a
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-4">
&lt;summary>【git】roomba_hackリポジトリをcloneし移動する&lt;/summary>
&lt;p>&lt;pre>&lt;code class="language-shell">(開発PC):~/group_a$ git clone https://github.com/matsuolab/roomba_hack.git
# group_a ディレクトリの中に新しいディレクトリができていることを確認
(開発PC):~/group_a$ ls
(開発PC):~/group_a$ cd roomba_hack
(開発PC):~/group_a/roomba_hack$ ls
&lt;/code>&lt;/pre>
&lt;p>&lt;a href="https://github.com/matsuolab/roomba_hack">https://github.com/matsuolab/roomba_hack&lt;/a> をそのままダウンロードできたことが確認できると思います。&lt;/p>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-5">
&lt;summary>【git】ブランチを確認する&lt;/summary>
&lt;p>&lt;p>git branchコマンドを使ってみましょう。&lt;/p>
&lt;pre>&lt;code># ローカルブランチの一覧を表示
(開発PC):~/group_a/roomba_hack$ git branch
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-6">
&lt;summary>【docker】roomba_hackの開発環境のdockerイメージをビルドする&lt;/summary>
&lt;p>&lt;pre>&lt;code># shellファイルの中身をcatコマンドで確認してみる。
(開発PC):~/group_a/roomba_hack$ cat BUILD-DOCKER-IMAGE.sh
# ファイルの中身が表示される
# ファイルの最後の
# docker build . -f docker/${DOCKERFILE_NAME} -t ${IMAGE_NAME}:${TAG_NAME} --build-arg BASE_IMAGE=${BASE_IMAGE}
# の部分でDockerイメージのビルドを実行するようです。
# shellファイルを実行してビルドを行います。
(開発PC):~/group_a/roomba_hack$ ./BUILD-DOCKER-IMAGE.sh
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-7">
&lt;summary>【ssh】jetsonにsshする&lt;/summary>
&lt;p>&lt;p>開発用PCからルンバに載っているjetson nanoへsshします。&lt;/p>
&lt;pre>&lt;code>(開発PC):~/group_a/roomba_hack$ ssh roomba_dev2
roomba_dev2@roomba-dev-jetson2:~$
&lt;/code>&lt;/pre>
&lt;p>先頭の表記が&lt;code>roomba_dev2@roomba-dev-jetson2&lt;/code>と変わり、jetsonへ接続されたことがわかります。&lt;/p>
&lt;p>jetsonでも同様にグループのディレクトリを作成し、移動し、roomba_hackリポジトリをcloneしてみましょう。&lt;/p>
&lt;/p>
&lt;/details>
&lt;!--
&lt;details class="spoiler " id="spoiler-8">
&lt;summary>【ssh】VNCを使う&lt;/summary>
&lt;p>&lt;p>個人PCから開発PCにsshで接続&lt;/p>
&lt;pre>&lt;code class="language-shell">(個人PC):~$ ssh robot_dev2 -L 5900:localhost:5900
&lt;/code>&lt;/pre>
&lt;p>手元のVNC viewerでlocalhost:5900を開く&lt;/p>
&lt;/p>
&lt;/details>
-->
&lt;!--
TODO:
- RUN-DOCKER-CONTAINER.shの中身を説明する
- BUILD-DOCKER-IMAGE.shの中身を説明する
- sshに必要な設定を説明する
- VNCに必要な設定を説明する
- VNC viewerの使い方を説明する
--></description></item><item><title>ROSとは</title><link>https://matsuolab.github.io/roomba_hack_course/course/chap1/ros/</link><pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate><guid>https://matsuolab.github.io/roomba_hack_course/course/chap1/ros/</guid><description>&lt;p>ロボット開発によく用いられるROSの概要を理解する&lt;/p>
&lt;h2 id="learn">Learn&lt;/h2>
&lt;h3 id="rosの概要">ROSの概要&lt;/h3>
&lt;p>ROS(Robot Operating System)は、ロボット・アプリケーション開発に便利な機能を提供するフレームワークです。
フレームワークとは、プログラミング言語を特定の目的に特化させて使うためのツールのことです。
具体的には以下にあげる機能を提供しています。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>メッセージ通信&lt;/p>
&lt;ul>
&lt;li>プロセス間、コンピュータ間の通信ライブラリが提供されています。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>デバイスドライバ&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ROSに対応しているセンサやアクチュエータを搭載したロボットであれば、違うロボットであってもほぼ同じソースコードを使用して動かすことができます。&lt;br>
roombaを動かすために書いたソースコードをそのまま使用してHSRを動かす、といったことができます。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/ros-drivers">https://github.com/ros-drivers&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="http://wiki.ros.org/Sensors">http://wiki.ros.org/Sensors&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ライブラリ&lt;/p>
&lt;ul>
&lt;li>ロボットを動作させるソフトウェア(ナビゲーション、マニピュレーション)の基本機能の大半が提供されています。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>視覚化ツール&lt;/p>
&lt;ul>
&lt;li>ロボットの内部状態やセンサ出力を2次元、3次元で視覚化するRvizや3次元動力学シミュレータのGazeboなどが提供されています。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>パッケージ管理&lt;/p>
&lt;ul>
&lt;li>多種多様なプログラミング言語(python, C++, &amp;hellip;)、依存関係で記述されたプログラム同士を統合的に使用することが可能です。&lt;/li>
&lt;li>これにより、経路計画など処理が重いプロセスはC++でコードを書き、画像認識など機械学習系のプロセスはpythonでコードを書く、といったこともできるようになります。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="rosのメッセージ通信">ROSのメッセージ通信&lt;/h3>
&lt;p>ロボットを動かす際には、多くのプログラムを並列して実行し、それぞれがデータをやりとりする必要があります。
ROSはそのようなプログラム間の通信に必要な機能を提供しています。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ノード(node)&lt;/p>
&lt;ul>
&lt;li>ROSでは、一つのプログラム単位を「ノード(node)」と呼びます。&lt;/li>
&lt;li>基本的には、一つのファイルが一つのノードに対応しています。&lt;/li>
&lt;li>各ノードは次に述べるtopic、service、actionの三つの通信方法を使って、他のノードとデータのやり取りを行います。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>トピック(topic)&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ROSでの、最も基本的なデータ通信の経路を「トピック(topic)」と呼びます。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ノードはメッセージをトピックへ向けて配信(Publish)し、また購読する(Subscribe)ことで他のノードと情報を共有することができます。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配信を行うノードをPublisher、購読を行うノードをSubscriberと呼びます。ノードはこのどちらかに二分することができるというわけではなく、実際には一つのノードがpublisherであり、subscriberでもあるという状況がほとんどです。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>トピックには名前が付けられており、同じトピックに複数のノードがデータを送ったり、複数のノードが同じデータを受け取ることができます。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>メッセージ(message)&lt;/p>
&lt;p>トピックへ配信したり、購読したりするときのROSのデータ型のことを「メッセージ(message)」と呼びます。
メッセージの型はmsgファイルに記述されており、使用するプログラミング言語に依存しないデータ形式になっています。&lt;/p>
&lt;p>以下に、物体やロボットの位置を表す時によく用いる&lt;code>geomemtry_msgs/PoseStamped&lt;/code>型のmsgファイルを示します。
位置情報の時間や座標フレームの情報が含まれるheaderと座標位置を表すposeで定義されています。&lt;/p>
&lt;pre>&lt;code>std_msgs/Header header
uint32 seq
time stamp
string frame_id
geometry_msgs/Pose pose
geometry_msgs/Point position
float64 x
float64 y
float64 z
geometry_msgs/Quaternion orientation
float64 x
float64 y
float64 z
float64 w
&lt;/code>&lt;/pre>
&lt;p>各行の左側にはデータ型が、右側には変数名が記述されています。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Topic通信のイメージ
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../node.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>サービス(service)&lt;/p>
&lt;ul>
&lt;li>
&lt;p>「サービス(service)」も、ノードが他のノードと通信するための手段の一つです。少しだけtopicより複雑な通信の仕方を提供します.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>サービスには、サービスを提供するノード（service server）とサービスを要求するノード(service client)があります。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>サービスは以下のような流れで使用されます。&lt;/p>
&lt;ol>
&lt;li>service clientがservice serverに引数を渡す。&lt;/li>
&lt;li>引数を受け取ったservice serverが何らかのプログラムを実行する。&lt;/li>
&lt;li>service serverは行為の結果を返り値としてservice clientに返す。&lt;/li>
&lt;li>service clientはその返り値に応じて後の挙動を変える。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>サービスにおいて送受信されるデータの型は.srvファイルに記述されています。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>メッセージと同様使用言語に依存しないデータ形式ですが、メッセージと異なるのは、引数と戻り値の二つの形式を定義する必要があるところです。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以下に、srvの例として&lt;code>std_srvs/SetBool&lt;/code>を示します。
このように引数と戻り値の間に&lt;code>---&lt;/code>を入れて定義します。&lt;/p>
&lt;pre>&lt;code>bool data
---
bool success
string message
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>service通信のイメージ
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../ros_service.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>アクション(action)&lt;/p>
&lt;ul>
&lt;li>アクションもノード間通信の一つの手段です。serviceよりもさらに複雑な通信ができます。&lt;/li>
&lt;li>トピックやサービスほど頻繁には使われないので、ここでは説明を省略します。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ROSマスタ(ROS master)&lt;/p>
&lt;ul>
&lt;li>
&lt;p>「ROSマスタ(ROS master)」は、ノード、トピックおよびサービスの名前登録を行い、それぞれのノードが他のノードから見えるようにする役割を担っています。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通信するノード名とトピック名およびサービス名の対応が決定した後、ノード同士が「peer-to-peer」で通信します。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ROSマスタを起動するには「roscore」というコマンドを実行します（が、RoombaやHSRをつかうときにはこのコマンドが自動で実行されることが多いため、あまり意識する機会はないかもしれません）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!--
パラメータサーバは必須ではないと思うのでコメントアウト。
- パラメータサーバ(parameter server)
「パラメータサーバ(parameter server)」は、設定データを複数のノードで共有するための軽量なサーバです。
各ノードのパラメータを、パラメータサーバで一括して管理できます。
パラメータサーバもROSマスタ同様に「roscore」コマンドで起動します。
パラメータサーバで扱える型は、整数・小数・真偽値・辞書・リストになります。
-->
&lt;!--
- ROSのデータ通信のまとめ
&lt;figure id="figure-ros通信">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../ros_communication.png" alt="ROS通信" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
ROS通信
&lt;/figcaption>&lt;/figure>
-->
&lt;!-- ### デバイスドライバ
- カメラ
- LiDAR
- IMU -->
&lt;h3 id="rosと連動するソフトウェア">ROSと連動するソフトウェア&lt;/h3>
&lt;p>ROSは以下のようなソフトウェアと連動して使うためのパッケージを提供しています。簡単な説明にとどめるので、詳しい使い方は必要になったときに勉強してください。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>OpenCV&lt;/p>
&lt;p>豊富な機能を持つ2D画像処理用のライブラリです。
カメラで撮影した画像を処理する際に使用します。&lt;/p>
&lt;!--
OpenCVのデータ形式である、MatクラスとROSのメッセージ形式を変換するcv_bridgeや３次元座標上の物体を２次元画像上に投影する機能であるimage_geometryといったパッケージ(vision_opencv)が提供されています。
-->
&lt;/li>
&lt;li>
&lt;p>PCL(Point Cloud Library)&lt;/p>
&lt;ul>
&lt;li>3次元点群処理のライブラリ。&lt;/li>
&lt;li>HSRやRoombaにはRGBDカメラが搭載されています。DはDepthという意味で、画像の各ピクセルに距離情報を対応させたDepth画像を取得することができます。&lt;br>
このような三次元の点群の情報を処理する際にPCLを使うと便利です。&lt;/li>
&lt;/ul>
&lt;!--OpenCV同様PCLのデータ形式とROSのメッセージ形式を変換するパッケージが提供されています。-->
&lt;/li>
&lt;li>
&lt;p>OpenSLAM&lt;/p>
&lt;ul>
&lt;li>地図を効果的に使うことで、より安定したロボットのナビゲーションを行うことができます。&lt;/li>
&lt;li>移動ロボットの自己位置推定と地図生成を同時に行うSLAM(Simultaneous Localization and Mapping)という手法は、それだけで一つの研究分野になる程奥深い分野で、活発に研究が行われています。&lt;/li>
&lt;li>OpenSLAMは、SLAMのソースコードを公開するためのプラットフォームを提供しており、様々なSLAMの手法を実装しています。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;!--
roombaには手がついていないので、MoveIt!の説明は省略。
- **Move it**
-->
&lt;p>これ以外にも本当にたくさんのツールがROSと連動しています。&lt;/p>
&lt;h3 id="可視化ツール">可視化ツール&lt;/h3>
&lt;p>ロボット内部の大量のデータが正しく処理されているか知りたい場合、変数の中身の数値などを直接みるのは大変です。直感的にわかりづらいためミスも増えます。&lt;br>
可視化をすることで、開発やデバッグがより効率よく進められます。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>rqt&lt;/p>
&lt;p>rqtはROSのGUIフレームワークで、様々なツールを提供しています。&lt;br>
ノードの状態を可視化する&lt;code>rqt_graph&lt;/code>(下図1)、メッセージの値を時系列に沿ってプロットする&lt;code>rqt_plot&lt;/code>(下図2)などがあります。&lt;/p>
&lt;figure id="figure-図1-rqt_graph-wikipediahttpwikirosorgrqt_graphより引用">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../rqt_graph.png" alt="図1 rqt_graph [wikipedia](http://wiki.ros.org/rqt_graph)より引用" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
図1 rqt_graph &lt;a href="http://wiki.ros.org/rqt_graph">wikipedia&lt;/a>より引用
&lt;/figcaption>&lt;/figure>
&lt;figure id="figure-図2-rqt_plot-wikipediahttpwikirosorgrqt_plotより引用">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="../rqt_plot.png" alt="図2 rqt_plot [wikipedia](http://wiki.ros.org/rqt_plot)より引用" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
図2 rqt_plot &lt;a href="http://wiki.ros.org/rqt_plot">wikipedia&lt;/a>より引用
&lt;/figcaption>&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;!-- http://wiki.ros.org/rqt -->
&lt;ul>
&lt;li>
&lt;p>RViz&lt;/p>
&lt;p>ロボットの三次元モデルや座標系、測定した三次元点群などを可視化するツールです。&lt;br>
三次元空間の情報以外に、カメラに写っている画像なども表示できます。&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe src="https://www.youtube.com/embed/i--Sd4xH9ZE" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video">&lt;/iframe>
&lt;/div>
&lt;!-- http://wiki.ros.org/ja/rviz -->
&lt;/li>
&lt;li>
&lt;p>gazebo&lt;/p>
&lt;p>オープンソースのロボット用三次元動力学シミュレータ。&lt;br>
説明は割愛します。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;!-- ### パッケージ管理
- プログラミング言語
- rosdep
- -->
&lt;h2 id="演習">演習&lt;/h2>
&lt;details class="spoiler " id="spoiler-6">
&lt;summary>&lt;strong>roombaドライバを起動し、動作していることを確認する&lt;/strong>&lt;/summary>
&lt;p>&lt;ul>
&lt;li>
&lt;p>jetsonにアクセスする&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC):~$ ssh roomba_dev1
(jetson):~$
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>docker containerを起動する&lt;br>
余裕があれば&lt;code>RUN-DOCKER-CONTAINER.sh&lt;/code>ファイルの中身を確認してみましょう。&lt;/p>
&lt;pre>&lt;code class="language-sh">(jetson):~$ cd ~/team_a/roomba_hack
(jetson):~/team_a/roomba_hack$ ./RUN-DOCKER-CONTAINER.sh
root@roomba-dev-jetson:~/roomba_hack#
&lt;/code>&lt;/pre>
&lt;p>&lt;code>root@roomba-dev-jetson:~/roomba_hack#&lt;/code>などと表示されればdocker内部に入れています。&lt;/p>
&lt;p>今後docker内部であることは(docker)と表記します。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>roomba driverなどを起動するlaunchファイルを起動する&lt;br>
このタイミングでルンバの電源が入っているかを確認しておきましょう。&lt;/p>
&lt;pre>&lt;code class="language-sh">(jetson)(docker):~/roomba_hack# roslaunch roomba_bringup bringup.launch
&lt;/code>&lt;/pre>
&lt;p>起動に成功すればルンバからピッと短い音が鳴り、ターミナルには赤い文字が出続けるはずです。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-7">
&lt;summary>&lt;strong>コントローラーを使ってロボットを動かす&lt;/strong>&lt;/summary>
&lt;p>&lt;ul>
&lt;li>
&lt;p>開発PCでdocker containerを起動する&lt;br>
xにはroomba_devの後につく数字を入れてください。&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC):~$ cd ~/team_a/roomba_hack
(開発PC):~/team_a/roomba_hack$ ./RUN-DOCKER-CONTAINER.sh 192.168.10.7x
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>コントローラーを起動&lt;br>
コントローラーが開発PCに刺さってることを確認してください。&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC)(docker):~/roomba_hack# cd catkin_ws
(開発PC)(docker):~/roomba_hack/catkin_ws# catkin_make
(開発PC)(docker):~/roomba_hack/catkin_ws# source devel/setup.bash
(開発PC)(docker):~/roomba_hack/catkin_ws#roslaunch roomba_teleop teleop.launch
&lt;/code>&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>コントローラのモード&lt;/p>
&lt;ul>
&lt;li>移動・停止&lt;/li>
&lt;li>自動・マニュアル&lt;/li>
&lt;li>ドッキング・アンドッキング&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>コントローラによる操縦&lt;/p>
&lt;ul>
&lt;li>移動ロック解除
L1を押している時のみ移動コマンドが動作します。&lt;/li>
&lt;li>左ジョイスティック
縦方向で前進速度(手前に倒すとバック)、横方向は回転速度に対応しています。&lt;/li>
&lt;li>左矢印
それぞれ、一定に低速度で前進・後退・回転します。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>正常に起動できているかを確認&lt;br>
開発PCで新しくターミナルを開いてdockerの中に入ります。&lt;/p>
&lt;p>すでに開発PCで起動されているdockerコンテナに入る場合は、&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC):~/group_a/roomba_hack$ docker exec -it roomba_hack bash
&lt;/code>&lt;/pre>
&lt;p>または&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC):~/group_a/roomba_hack$ ./RUN-DOCKER-CONTAINER.sh
&lt;/code>&lt;/pre>
&lt;p>のいずれかの方法で入ることができます。&lt;/p>
&lt;p>さまざまなコマンドを使ってroombaの情報を取得してみましょう。&lt;/p>
&lt;pre>&lt;code class="language-sh">(開発PC)(docker):~/roomba_hack# rosnode list
(開発PC)(docker):~/roomba_hack# rostopic list
(開発PC)(docker):~/roomba_hack# rostopic echo /cmd_vel
(開発PC)(docker):~/roomba_hack# rqt_graph
(開発PC)(docker):~/roomba_hack# rviz
&lt;/code>&lt;/pre>
&lt;/li>
&lt;/ul>
&lt;/p>
&lt;/details></description></item></channel></rss>